\documentclass[a4paper,12pt]{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{color}
\usepackage[margin=2cm]{geometry}

\usepackage[framed,autolinebreaks]{mcode}
%useliterate can be added to do things like write <= properly.
%numbered adds line numbers to the code

\pagestyle{fancy}
\chead{10299169}
\setlength\parindent{24pt}
\graphicspath{ {.} }


\begin{document}

\begin{center}
\Large\textsc{Problem Solving by Computer MATH36032}
\Large\textsc{Coursework 1}
\end{center}

\noindent\large\underline{Question 1:} \hspace{0.25cm} Write a function \verb!AppEM! such that \verb![p,q] = AppEM(N)! returns the best pair of integers $p$ and $q$, such that $|\frac{p}{q}-\gamma|$ is smallest amongst all positive integers and $p+q$ is less than or equal to $N$.  Record your result for $N= 2021$. 

To write this function, I wanted to find a way of seaching through integers $m$ and $n$ in an efficient way to find the best pair $p$ and $q$. To do this I assign a temporary best pair \verb![p, q]! which I compare the current pair of integers on each loop, \verb![m, n]!, against. If $|\frac{m}{n}-\gamma| <  |\frac{p}{q}-\gamma|$ then I update the temporary best pair to \verb![p, q] = [m, n]!. If two best pairs are found, I want to take the pair with the lowest $p+q$. Notice that the values of $m$ and $n$ are strictly increasing on each loop. So if another best pair \verb![m, n]! is found, it will always be true that $m+n > p+q$, therefore we will not need to update our temporary best pair (ie. we do not need to write any extra code).

%I turned my attention to the constraint $p + q \le N$.

\lstinputlisting{AppEm.m}

 % matlab code environment
\begin{lstlisting}
>> [p,q] = AppEM(2021)
p =
   228
q =
   395
\end{lstlisting}
\newpage
\noindent\large\underline{Question 2:} \hspace{0.25cm} Write a function \verb!MyLuckynum! such that \verb!MyLuckynum(N)! returns the smallest MyLucky number greater than or equal to $N$.  Record your output for $N=2021$.

For this question, I wrote a function that scans through a list of numbers, and performs a series of checks on each to decide whether or not it is a MyLucky number. I found three checks I wanted to perform and decided to write each as a seperate function which returns \verb!true! or \verb!false!, as I found it easier to express the final function \verb!MyLuckynum! as an implementation of these components.

The first thing I checked was whether a given $n$ has only odd prime factors. Observe that 2 is the only even prime, so we can rephrase the problem as: Does $n$ have 2 as a prime factor? If not, it must have only odd prime factors. The \textsc{matlab} function \verb!factor(n)! works in our favour here as the vector of prime factors it outputs is written in ascending order, so if 2 is a factor of $n$ we will find it in the first entry of that vector.
\lstinputlisting{check1.m}

The second thing I checked was whether a given $n$ has distinct prime factors. Verifying this was a simple case of scanning through the vector of prime factors of $n$ generated by \verb!factor(n)! and comparing each entry with the one after it to find any repeats.
\lstinputlisting{check2.m}\newpage

The third thing I checked was whether for all prime factors $p$ of $n$,  $p-1 \mid n-1$. To answer this, I needed to describe the notion of `divides' in \textsc{matlab}. I wrote a function \verb!divides(a,b)! to tell whether or not $a \mid b$, where we know $a,b \in \mathbb{Z}$ for our uses. It works on the idea that if $a \nmid b$, then $10 \times \frac{b}{a}$ will have non-zero residue mod 10. I used the \textsc{matlab} function \verb!mod(x,y)! to find this residue.
\lstinputlisting{divides.m}

Now we can write third check by looking at each element $p$ of the vector of prime factors of $n$ and finding \verb!divides(p-1,n-1)!.
\lstinputlisting{check3.m}

Finally, I wrote the \verb!MyLuckynum(N)! function. I'm able to quickly verify whether each $n$ is a MyLucky number using a simple \verb!if! statement, and this was why I wrote the conditions for $n$ to be MyLucky number as the three checks above. I've also included an \verb!if! statement to discard any prime numbers from the search before going through all of the checks, to speed up the computation. Here is the function: \newpage
\lstinputlisting{MyLuckynum.m}

\begin{lstlisting}
>> MyLuckynum(2021)
ans =
        2465
\end{lstlisting}

\noindent\large\underline{Question 3:} \hspace{0.25cm} Find the beautiful square number $n$, such that $n^2$ is closest to 360322021.



When I read this question I decided to first try and make a list of all beautiful square numbers. I needed to write a function that would search a list of integers and find any beautiful square numbers $n$. That is, any $n$ such that $n^2$ consists of all nine non-zero digits exactly once. So how many numbers should we search? Simply, we want to search up to the smallest $n$ such that $n^2 \geq 987654321$, the largest possible number consisting of all nine non-zero digits exactly once. To find this upper limit, I wrote a function \verb!searchlimit(N)!:

\lstinputlisting{searchlimit.m}

\begin{lstlisting}
>> searchlimit(987654321)
ans =
       31427
\end{lstlisting}

Next I wrote a function \verb!listBeautisqnum()! to search through all the nine digit square numbers up to $31427^2$ and find beautiful squares. To identify a beautiful square, I chose to convert each number $n^2$ into a vector of its digits then used the \textsc{matlab} function \verb!sort(A)! to arrange the elements of the vector in ascending order. To convert each number into digits I used the \verb!num2dig(n)! function written in the lab demonstrations which I have also included below (with some added comments to show how it works). Now, if $n$ is a beautiful square number then the sorted vector of digits of $n^2$ will equal the vector $(1, 2, 3, 4, 5, 6, 7, 8, 9)$.

\lstinputlisting{num2dig.m}

\lstinputlisting{listBeautisqnum.m}

\begin{lstlisting}
>> listBeautisqnum
ans =
  Columns 1 through 9
       30384       29106       29034       27273       27129       26733       26409       25941       25572
  Columns 10 through 18
       25059       24807       24441       24276       24237       23439       23178       23019       22887
  Columns 19 through 27
       20316       19629       19569       19377       19023       18072       15963       15681       14676
  Columns 28 through 30
       12543       12363       11826
\end{lstlisting}

Finally, I wrote the function \verb!Beautisqnum(N)! to find the value of $n$ such that $n^2$ is closest to $N$. What I have written searches through elements of a given vector, and updates the value of $n$ each time it finds a new `best' value. Now that we know all the beautiful square numbers, we know in particular that the smallest such number is 11826, which I used as the initial closest value. Additionally, we can narrow down the search in the final function to just 30 numbers, which is a huge increase in efficiency! Note that in the code I have written below, I call \verb!listBeautisqnum()! at the start, but I have only written this for brevity and in practice it would be faster (computationally) to assign to a variable the pre-calculated vector of beautiful squares rather than having to generate the list every time.

There are cases when one can find two nearest beautiful squares. For example, I found that 250355565 is equidistant to 15681 and 15963 after a brief search. To account for this, I added an \verb!elseif! statement which will output the two numbers as a vector when this happens.

\lstinputlisting{Beautisqnum.m}

\begin{lstlisting}
>> Beautisqnum(360322021)
ans =
       19023
\end{lstlisting}

\end{document}